---
# https://clang.llvm.org/docs/ClangFormatStyleOptions.html

Language:        Cpp
# BasedOnStyle:  Microsoft

AccessModifierOffset: -4
AlignAfterOpenBracket: Align
AlignConsecutiveMacros: true
AlignConsecutiveAssignments: true
AlignConsecutiveDeclarations: true
AlignEscapedNewlines: Left
AlignOperands:   false
AlignTrailingComments: true
AllowAllArgumentsOnNextLine: true
AllowAllConstructorInitializersOnNextLine: true
AllowAllParametersOfDeclarationOnNextLine: false
AllowShortBlocksOnASingleLine: Always
AllowShortCaseLabelsOnASingleLine: true

AllowShortFunctionsOnASingleLine: All
AllowShortLambdasOnASingleLine: Inline
AllowShortIfStatementsOnASingleLine: Always
AllowShortLoopsOnASingleLine: true

# The function definition return type breaking style to use.
# This option is deprecated and is retained for backwards compatibility.
AlwaysBreakAfterDefinitionReturnType: None

AlwaysBreakAfterReturnType: None
AlwaysBreakBeforeMultilineStrings: false
AlwaysBreakTemplateDeclarations: No

BinPackArguments: true
BinPackParameters: false

# Cuatom: Configure each individual brace in BraceWrapping.
BreakBeforeBraces: Custom

BraceWrapping:
  AfterCaseLabel: true
  # true:
  # case 1
  # {
  #     bar();
  #     break;
  # }


  AfterClass: true
  # true:
  # class A
  # {


  # Only wrap braces after a multi-line control statement.
  AfterControlStatement: Always
  # MultiLine:
  # if (foo && bar)
  # {
  #     quux();
  # }
  # while (foo || bar)
  # {}


  AfterEnum: true
  # true:
  # enum X : int
  # {
  #     B
  # };


  AfterFunction: true
  # void foo()
  # {
  #     bar();
  #     bar2();
  # }


  AfterNamespace: true
  # true:
  # namespace
  # {
  # int foo();


  # Wrap ObjC definitions (interfaces, implementations...). @autoreleasepool and @synchronized
  # blocks are wrapped according to AfterControlStatement flag.
  AfterObjCDeclaration: true


  AfterStruct: true
  # true:
  # struct foo
  # {
  #     int x;
  # };


  AfterUnion: true
  # true:
  # union foo
  # {
  #     int x;
  # }


  AfterExternBlock: true
  # true:
  # extern "C"
  # {
  #     int foo();
  # }


  BeforeCatch: true
  # true:
  # }
  # catch ()


  BeforeElse: true
  # true:
  # }
  # else


  #BeforeLambdaBody: true - not available in 10.0
  #true:
  #connect(
  #  []()
  #  {
  #    foo();
  #    bar();
  #  });


  # Indent the wrapped braces themselves.
  IndentBraces: false

  # If false, empty function body can be put on a single line
  SplitEmptyFunction: false

  # If false, empty record (e.g. class, struct or union) body can be put on a single line.
  SplitEmptyRecord: false

  #  If false, empty namespace body can be put on a single line.
  SplitEmptyNamespace: false

# The way to wrap binary operators.
BreakBeforeBinaryOperators: None


BreakBeforeInheritanceComma: false

BreakInheritanceList: AfterColon
# AfterColon:
# class Foo :
#     Base1,
#     Base2
# {};


# If true, ternary operators will be placed after line breaks.
BreakBeforeTernaryOperators: false
# false:
# veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?
#     firstValue :
#     SecondValueVeryVeryVeryVeryLong;

BreakConstructorInitializersBeforeComma: false

BreakConstructorInitializers: AfterColon
# Constructor() :
#     initializer1(),
#     initializer2()

BreakAfterJavaFieldAnnotations: false

# Allow breaking string literals when formatting.
BreakStringLiterals: false

# A column limit of 0 means that there is no column limit. In this case, clang-format will
# respect the input's line breaking decisions within statements unless they contradict other rules.
ColumnLimit: 0

# A regular expression that describes comments with special meaning, which should not be split into lines or otherwise changed.
CommentPragmas:  '^ IWYU pragma:'

# If true, consecutive namespace declarations will be on the same line.
CompactNamespaces: false
# false:
# namespace Foo
# {
# namespace Bar
# {
# }
# }

# If the constructor initializers don't fit on a line, put each initializer on its own line.
ConstructorInitializerAllOnOneLineOrOnePerLine: true

ConstructorInitializerIndentWidth: 4
ContinuationIndentWidth: 4

# If true, format braced lists as best suited for C++11 braced lists.
Cpp11BracedListStyle: true
DerivePointerAlignment: false
DisableFormat:   false
ExperimentalAutoDetectBinPacking: false
# If true, clang-format adds missing namespace end comments and fixes invalid existing ones.
FixNamespaceComments: true

# Indent case labels one level from the switch statement.
IndentCaseLabels: true
#   true:
#   switch(foo)
#   {
#       case bar:

IndentGotoLabels: true

# The preprocessor directive indenting style to use.
IndentPPDirectives: AfterHash
# #if FOO
# #  if BAR
# #    include <foo>
# #  endif
# #endif


IndentWidth:     4
IndentWrappedFunctionNames: false
JavaScriptQuotes: Leave
JavaScriptWrapImports: true

# If true, the empty line at the start of blocks is kept.
KeepEmptyLinesAtTheStartOfBlocks: true
MacroBlockBegin: ''
MacroBlockEnd:   ''

# The maximum number of consecutive empty lines to keep.
MaxEmptyLinesToKeep: 10000

# The indentation used for namespaces.
NamespaceIndentation: None

ObjCBinPackProtocolList: Auto
ObjCBlockIndentWidth: 4
ObjCSpaceAfterProperty: false
ObjCSpaceBeforeProtocolList: true
PenaltyBreakAssignment: 2
PenaltyBreakBeforeFirstCallParameter: 19
PenaltyBreakComment: 300
PenaltyBreakFirstLessLess: 120
PenaltyBreakString: 1000
PenaltyBreakTemplateDeclaration: 10
PenaltyExcessCharacter: 1000000
PenaltyReturnTypeOnItsOwnLine: 1000

PointerAlignment: Left
# left:
# int* a;
# int& b;

# If true, clang-format will attempt to re-flow comments.
ReflowComments:  false

SortIncludes:    false
SortUsingDeclarations: false
SpaceAfterCStyleCast: false
# false:
# (int)i;


SpaceAfterLogicalNot: false
# false:
# !bar();

SpaceAfterTemplateKeyword: true
# true:
# template <typename>


SpaceBeforeAssignmentOperators: true
# true:
# int a =

# If true, a space will be inserted before a C++11 braced list used to
# initialize an object (after the preceding identifier or type).
SpaceBeforeCpp11BracedList: false
# false:
# vector<int>{1, 2, 3};


SpaceBeforeCtorInitializerColon: true
# true:
# Foo::Foo() : a(a) {}


SpaceBeforeInheritanceColon: true
# true:
# class Foo : Bar {}


# Put a space before opening parentheses only after control statement keywords (for/if/while...)
SpaceBeforeParens: ControlStatements
# ControlStatements:
# void f() {
#   if (true) {
#     f();
#   }
# }


SpaceBeforeRangeBasedForLoopColon: true
# true:
# for (auto v : values) {}


SpaceInEmptyBlock: false
# false:
# void f() {}


SpaceInEmptyParentheses: false
# false:
# f();

SpacesBeforeTrailingComments: 1

SpacesInAngles:  false

SpacesInContainerLiterals: true
# false:
# var arr = [1, 2, 3];


SpacesInCStyleCastParentheses: false
# false:
# x = (int32)y


SpacesInParentheses: true
# false:
# t f(Deleted &) & = delete;

SpacesInSquareBrackets: true
# false:
# int a[5];


Standard:        Latest

TabWidth:        4
UseTab:          Never